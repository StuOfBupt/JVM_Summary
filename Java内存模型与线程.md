#### 1、Java内存模型

- 缓存一致性问题

- **Java内存模型**

  ![image-20201128172919574](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201128172919574.png?token=AHMLWBMUTQE7T7WSNNTEXHS7YIMLA)

  - Java内存模型规定了所有的变量都存储在**主内存**（Main Memory）中
  - 每条线程还有自己的**工作内存**（Working Memory，可与处理器高速缓存类比），线程的**工作内存中保存了被该线程使用的变量的主内存副本**，**线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据**。
  - 不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存来完成**

- 内存间的交互操作：Java内存模型中定义了以下8种操作来完成。实现时必须保证每一种操作都是原子的、不可再分的

  - lock（锁定）：作用于主内存的变量，它把一个变量标识为一条**线程独占的状态**。
  - unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中
  - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
  - use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
  - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
  - store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
  - write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

- 内存间交互操作需要满足的规则

  - 不允许read和load、store和write操作之一单独出现
  - 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
  - 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中
  - 一个**新的变量只能在主内存中“诞生”**，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量
  - 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
  - 如果**对一个变量执行lock操作，那将会清空工作内存中此变量的值**，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值【加锁时要重新从主内存读取变量的值】
  - 如果一个变量没有被lock锁定，不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
  - **对一个变量执行unlock操作之前，必须先把此变量同步回主内存中**（执行store、write操作）【解锁时要将更新后的变量刷新到主内存】

- volatile型变量的特殊规则

  - volatile关键字是Java虚拟机提供的**最轻量级的同步机制**

  - 声明volatile变量具备两项特性：

    - 保证**此变量对所有线程的可见性**，这里的“可见性”是指当一条线程修改了这个变量的值，**新值对于其他线程来说是可以立即得知**的。【普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成】
    - 禁止指令重排优化：普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致,在某些情况下，为了保证按照代码中的执行顺序进行，需要指定变量为volatile

  - 尽管volatile变量对所有线程是立即可见的，也不能保证基于volatile变量的运算在并发下是线程安全的，因为Java的运算操作符并不是原子操作

  - volatile如何实现线程可见和禁止指令重排？

    - 每次使用volatile变量前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量所做的修改；每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改。 

    - 有volatile修饰的变量，赋值后多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 

      （指重排序时不能把后面的指令重排序到内存屏障之前的位置），lock addl$0x0，(%esp)【把ESP寄存器的值加0，是个空操作】指令把修改同步到内存时，该写入动作也会引起别的处理器或者别的内核无效化其缓存，这种操作相当于对缓存中的变量做了一次“store和write”操作，通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见，这样便形成了“指令重排序无法越过内存屏障”的效果

- long和double的非原子性协定

  - 允许虚拟机将**没有被volatile修饰的64位数据**的读写操作**划分为两次32位的操作**来进行，即允许虚拟机实现自行选择是否 

    要保证64位数据类型的load、store、read和write这四个操作的原子性。因此如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值，这个问题现代的cpu已经可以解决

- Java提供了volatile和synchronized两个关键字来保证线程之间操作的**有序性**，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

  - synchronized同步块的可见性是由“**对一个变量执行unlock操作之前，必须先把此变量同步回主内存中**（执行store、write操 

    作）”这条规则获得的。

- 先行发生原则

  - 先行发生是Java内存模型中定义的**两项操作之间的偏序关系**，例如操作A先行发生于操作B，其实是说在**发生操作B之前，操作A产生的影响能被操作B观察到**，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

    ```java
    // Thread A
    i = 1;
    // Thread B
    j = i;
    // Thread C
    i = 2
    ```

    假设A中的操作先行发生于B，则能够确定B执行后变量j的值一定为1。得出这个结论的依据有两个：一是根据先行发生原则，“i=1”的结果可以被B观察到；二是线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值。

    再来考虑线程C，依然保持线程A和B之间的先行发生关系，而C出现在线程A和B的操作之间，但是C与B没有先行发生关系，那j的值就不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。

  - Java内存模型下的一些“天然的”先行发生关系，无需任何同步手段就能保证：

    - 程序次序规则：**在一个线程内**，按照**控制流顺序**，书写在前面的操作先行发生于书写在后面的操作

    - 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作

    - volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作

    - 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作

    - 线程终止规则：线程中的**所有操作都先行发生于对此线程的终止检测**，可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止 

      执行

    - 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

    - 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始

    - 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么A先行发生于操作C

  - 时间上先后发生与先行发生区别：

    ```java
    private int value = 0;
    public void setValue(int v){
      	value = v;
    }
    public int getValue(){
      	return value;
    }
    ```

    假设存在线程A和B，线程A先(时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？----不能确定 【时间上的先发生”不代表这个操作会是“先行发生”】

    > 由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；
    >
    > 由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；
    >
    > 由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；
    >
    > 后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。
    >
    > 因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起。
    >
    > 因此，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的。

    ```java
    // 同一个线程内
    int i = 1;
    int j = 2;
    ```

    在同一个线程之中，根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是**“int j=2”的代码完全可能先被处理器执行**(指令重排)，这并不影响先行发生原则的正确性，因为在这条线程之中没有办法感知到这一点。

    一个操作“先行发生”，不能推导出这个操作必定是“时间上的先发生”

#### 2、Java与线程

- **线程的实现**

  - 内核线程实现

    - 内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上
    - 程序一般使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是通常意义上的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型
    - 由于内核线程的支持，**每个轻量级进程都成为一个独立的调度单元**，**即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作**。轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，**需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换**。其次，每个 轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。
    - ![](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201129142002213.png?token=AHMLWBLXBCMFXCTW23DIE6K7YM65E)

  - 用户线程实现

    - 狭义上的用户线程指的是**完全建立在用户空间的线程库**上，系统内核不能感知到用户线程的存在及如何实现的。**用户线程的建立、同步、销毁和调度完全在用户态中完成**，不需要内核的帮助

    - 线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处 理器上”这类问题解决起来将会异常困难

      ![image-20201129142500617](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201129142500617.png?token=AHMLWBLMFYFFI2IF45A4BR27YM7P2)

  - 混合实现

    - 混合实现下，既存在用户线程，也存在轻量级进程。**用户线程还是完全建立在用户空间中**，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而**操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁**， 这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。

      ![image-20201129142629130](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201129142629130.png?token=AHMLWBMY55PGTHONXGRNVPK7YM7VK)

- Java线程调度

  - 协同式
    - 线程的执行时间由线程本身来控制，线程执行完了之后，要主动通知系统切换到另外一个线程上去。
    - 优点：实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，因此不需要线程同步的问题
    - 缺点：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞。
  - 抢占式（Java使用）
    - 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定
    - 可以通过设置线程优先级来“建议”操作系统给某些线程多分配或少分配一点执行时间

- 线程状态及其转换

  - 新建（new）：创建但未启动

  - 可运行（runnable）：此状态的线程可能在运行也可能在等待cpu分配时间

  - 无限期等待（waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要**等待被其他线程显式唤醒**

    - 没有设置Timeout参数的Object::wait()方法
    - 没有设置Timeout参数的Thread::join()方法
    - LockSupport::park()方法

  - 限期等待（timed waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒

    - Thread::**sleep**()方法
    - 设置了Timeout参数的Object::wait()方法
    - 设置了Timeout参数的Thread::join()方法
    - LockSupport::parkNanos()方法
    - LockSupport::parkUntil()方法

  - 阻塞（blocked）：线程被阻塞了，在程序等待进入同步区域的时候，线程将进入这种状态

    - “阻塞状态”与“等待状态”的区别是“阻塞状态”在**等待着获取到一个排它锁**，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生

  - 结束（terminated）：线程结束运行

    ![image-20201129145100403](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201129145100403.png?token=AHMLWBP6AFZXBC4KJHNBF6S7YNCRG)

#### 3、线程安全

- 线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用

- Java语言中的线程安全

  - 不可变：不可变（Immutable）的对象一定是线程安全的，如String类对象

  - 绝对线程安全：绝对的线程安全能够完全满足线程安全的定义，在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全

    - Vector容器：它的add()、get()和size()等方法都是被synchronized修饰的，但不意味着调用时永远不需要同步手段

      ```java
      private static Vector<Integer> vector = new Vector<Integer>(); 
      public static void main(String[] args) { 
        while (true) { 
          for (int i = 0; i < 10; i++) {
            vector.add(i); 
          }
          Thread removeThread = new Thread(new Runnable() { 
            @Override public void run() { 
              for (int i = 0; i < vector.size(); i++) { 
                vector.remove(i); 
              } 
            } 
          }); 
          Thread printThread = new Thread(new Runnable() { 
            @Override public void run() { 
              for (int i = 0; i < vector.size(); i++) { 
                System.out.println((vector.get(i))); 
              } 
            } 
          }); 
          removeThread.start(); 
          printThread.start(); 
          //不要同时产生过多的线程，否则会导致操作系统假死 
          while (Thread.activeCount() > 20); 
        } 
      }
      
      // run result
      // Exception in thread "Thread-132" java.lang.ArrayIndexOutOfBoundsException
      ```

      如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用，再用i访问数组就会抛出一个 

      ArrayIndexOutOfBoundsException异常，为了保证安全，必须对vector添加同步：

      ```java
      Thread removeThread = new Thread(new Runnable() { 
        @Override public void run() { 
          synchronized (vector) { 
            for (int i = 0; i < vector.size(); i++) { 
              vector.remove(i); 
            } 
          } 
        } 
      }); 
      Thread printThread = new Thread(new Runnable() { 
        @Override public void run() { 
          synchronized (vector) { 
            for (int i = 0; i < vector.size(); i++) { 
              System.out.println((vector.get(i))); 
            } 
          } 
        } 
      });
      ```

      假如对Vector一定要做到绝对的线程安全，那就必须在它内部维护一组一致性的快照访问才行，每次对其中元素进行改动都要产生新的快照。

  - 相对线程安全

    - 通常意义上所讲的线程安全，它需要保证**对这个对象单次的操作是线程安全的**，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
    - 大部分声称线程安全的类都属于这种类型，如**Vector、HashTable**、Collections的synchronizedCollection()方法包装的集合

  - 线程兼容：线程兼容是指**对象本身并不是线程安全的**，但是可以**通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用**，如**ArrayList、HashMap**

  - 线程对立：指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码

- 线程安全的实现方法

  - **互斥同步**（阻塞同步）：同步是指在多个线程并发访问共享数据时，**保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用**。而**互斥是实现同步的一种手段**，**临界区**（Critical Section）、**互斥量**（Mutex）和**信号量**（Semaphore）都是常见的互斥实现方式
    - Java中最基本的互斥同步手段是synchronized关键字。这是一种**块结构的同步语法**。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成**monitorenter**和**monitorexit**这两个字节码指令。这两个字节码指令**都需要一个reference类型的参数来指明要锁定和解锁的对象**。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在对象实例还是取类型对应的Class对象来作为线程要持有的锁。 
    - 在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。
    - 被synchronized修饰的同步块对同一条线程来说是可重入的，同一线程反复进入同步块也不会把自己锁死【重入锁】
    - 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入【重量级锁】
    - ReentrantLock也与synchronized相似，添加了一些高级功能：
      - **等待可中断**：是指当持有锁的线程长期不释放锁的时候，**正在等待的线程可以选择放弃等待，改为处理其他事情**
      - **公平锁**：是指**多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁**；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁
      - **锁绑定多个条件**：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可
  - **非阻塞同步**
    - 基于冲突检测的乐观并发策略，通俗地说就是**不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施**，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止
  - **无同步方案**
    - 如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性

#### 4、锁优化

- **自旋锁与自适应锁**

  - 自旋锁：为了让线程等待而不是被阻塞，我们只须让线程执行一个忙循环（自旋）使得请求锁的那个线程“稍等一会”，但**不放弃处理器的执行时间**，看看持有锁的线程是否很快就会释放锁。自旋等待本身**虽然避免了线程切换的开销，但它是要占用处理器时间**，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能的浪费，因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。
  - 自适应锁：对自旋锁的优化，自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的

- 锁消除：指虚拟机即时编译器在运行时，对一些代码要求同步，但是**对被检测到不可能存在共享数据竞争的锁进行消除**。锁消除的主要判定依据来源于逃逸分析的数据支持。

- 锁粗化：

  - 编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗
    - 例如连续的append()方法。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部

- **轻量级锁**：“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制就被称为“重量级”锁。轻量级锁是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

  - 加锁过程：

    - 在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word（对象头）的拷贝

    - 然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为“00”，表示此对象处于轻量级锁定状态。

    - 如果更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。**如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”**，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。

      

  - 解锁过程：

    - 同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁（锁标志变成了重量级锁，另一个线程在等待），就要在释放锁的同时，唤醒被挂起的线程

  - 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。

- **偏向锁**

  - 目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步
  - 加锁过程：
    - 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志 位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）
    - 若有另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行
    - ![image-20201130100629569](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201130100629569.png?token=AHMLWBORTQJ6PG2SWIPF4VK7YRJ6O)
  - 偏向状态时对象头HashCode的处理：
    - 当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码去哪了？
    - 在Java里一个对象如果计算过哈希码，就应该一直保持该值不变（但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。**当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了**；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求（重写的HasCode（）方法不会产生一致性哈希请求）时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，可以存储原来的哈希码。



