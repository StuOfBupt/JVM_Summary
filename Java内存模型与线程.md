#### 1、Java内存模型

- 缓存一致性问题

- **Java内存模型**

  ![image-20201128172919574](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201128172919574.png?token=AHMLWBMUTQE7T7WSNNTEXHS7YIMLA)

  - Java内存模型规定了所有的变量都存储在**主内存**（Main Memory）中
  - 每条线程还有自己的**工作内存**（Working Memory，可与处理器高速缓存类比），线程的**工作内存中保存了被该线程使用的变量的主内存副本**，**线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据**。
  - 不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存来完成**

- 内存间的交互操作：Java内存模型中定义了以下8种操作来完成。实现时必须保证每一种操作都是原子的、不可再分的

  - lock（锁定）：作用于主内存的变量，它把一个变量标识为一条**线程独占的状态**。
  - unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中
  - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
  - use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
  - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
  - store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
  - write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

- 内存间交互操作需要满足的规则

  - 不允许read和load、store和write操作之一单独出现
  - 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
  - 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中
  - 一个**新的变量只能在主内存中“诞生”**，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量
  - 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
  - 如果**对一个变量执行lock操作，那将会清空工作内存中此变量的值**，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值【加锁时要重新从主内存读取变量的值】
  - 如果一个变量没有被lock锁定，不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
  - **对一个变量执行unlock操作之前，必须先把此变量同步回主内存中**（执行store、write操作）【解锁时要将更新后的变量刷新到主内存】

- volatile型变量的特殊规则

  - volatile关键字是Java虚拟机提供的**最轻量级的同步机制**

  - 声明volatile变量具备两项特性：

    - 保证**此变量对所有线程的可见性**，这里的“可见性”是指当一条线程修改了这个变量的值，**新值对于其他线程来说是可以立即得知**的。【普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成】
    - 禁止指令重排优化：普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致,在某些情况下，为了保证按照代码中的执行顺序进行，需要指定变量为volatile

  - 尽管volatile变量对所有线程是立即可见的，也不能保证基于volatile变量的运算在并发下是线程安全的，因为Java的运算操作符并不是原子操作

  - volatile如何实现线程可见和禁止指令重排？

    - 每次使用volatile变量前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量所做的修改；每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改。 

    - 有volatile修饰的变量，赋值后多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 

      （指重排序时不能把后面的指令重排序到内存屏障之前的位置），lock addl$0x0，(%esp)【把ESP寄存器的值加0，是个空操作】指令把修改同步到内存时，该写入动作也会引起别的处理器或者别的内核无效化其缓存，这种操作相当于对缓存中的变量做了一次“store和write”操作，通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见，这样便形成了“指令重排序无法越过内存屏障”的效果

- long和double的非原子性协定

  - 允许虚拟机将**没有被volatile修饰的64位数据**的读写操作**划分为两次32位的操作**来进行，即允许虚拟机实现自行选择是否 

    要保证64位数据类型的load、store、read和write这四个操作的原子性。因此如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值，这个问题现代的cpu已经可以解决

- Java提供了volatile和synchronized两个关键字来保证线程之间操作的**有序性**，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

  - synchronized同步块的可见性是由“**对一个变量执行unlock操作之前，必须先把此变量同步回主内存中**（执行store、write操 

    作）”这条规则获得的。

- 先行发生原则

  - 先行发生是Java内存模型中定义的**两项操作之间的偏序关系**，例如操作A先行发生于操作B，其实是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

- 