#### 1、运行时数据区域划分

- ##### **方法区**：

  - **线程共享**
  - 用于存储已被虚拟机加载的`类型信息`、`常量`、`静态变量`等数据。
  - 这个区域较少出现垃圾收集行为，一般是针对常量池的回收和类型的卸载
  - 包含**运行时常量池**，常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

- **堆**

  - **线程共享**，在虚拟机启动时创建，用于存放对象实例。

- **虚拟机栈**：

  - **线程私有**，生命周期与线程相同。
  - 每个方法被调用时，Java虚拟机创建一个栈帧，用于存储局部变量表、操作数栈、动态链接等信息，一个方法被调用到执行完毕，对应着一个栈帧入栈到出栈的过程。
  - 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用和returnAddress 类型（指向了一条字节码指令的地址）。这些数据类型在局部变量表中的存储空间以`局部变量槽`（`Slot`）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小（这里的“`大小`”是指变量槽的数量）， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特等）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的。

- **本地方法栈**：

  - **线程私有**
  - 与虚拟机栈相似，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。【有些虚拟机将它们合二为一】

- **程序计数器**：

  - 一块较小的内存空间，是当前线程所执行的字节码的行号指示器。
  - **线程私有**，独立存储互不影响。

#### 2.直接内存

不是运行时数据区的一部分，是JDK1.4后引入的一种基于通道与环翠区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据，能在一些场景中显著提高性能。







