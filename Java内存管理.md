#### 1、运行时数据区域划分

![image-20201121154723497](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201121154723497.png?token=AHMLWBOUGUOSYDIG2XXOKKS7XDDE2)

- ##### **方法区**：

  - **线程共享**
  - 用于存储已被虚拟机加载的`类型信息`、`常量`、`静态变量`等数据。
  - 这个区域较少出现垃圾收集行为，一般是针对常量池的回收和类型的卸载
  - 包含**运行时常量池**，常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

- **堆**

  - **线程共享**，在虚拟机启动时创建，用于存放对象实例。

- **虚拟机栈**：

  - **线程私有**，生命周期与线程相同。
  - 每个方法被调用时，Java虚拟机创建一个栈帧，用于存储局部变量表、操作数栈、动态链接等信息，一个方法被调用到执行完毕，对应着一个栈帧入栈到出栈的过程。
  - 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用和returnAddress 类型（指向了一条字节码指令的地址）。这些数据类型在局部变量表中的存储空间以`局部变量槽`（`Slot`）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小（这里的“`大小`”是指变量槽的数量）， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特等）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的。

- **本地方法栈**：

  - **线程私有**
  - 与虚拟机栈相似，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。【有些虚拟机将它们合二为一】

- **程序计数器**：

  - 一块较小的内存空间，是当前线程所执行的字节码的行号指示器。
  - **线程私有**，独立存储互不影响。

#### 2、直接内存

不是运行时数据区的一部分，是JDK1.4后引入的一种基于通道与环翠区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据，能在一些场景中显著提高性能。

#### 3.、对象创建过程

- 类加载：检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。
- 分配内存
  - 对象所需的内存大小在类加载后可以完全确定
  - **指针碰撞**算法：假设java堆规整，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，
  - **空闲列表**分配：Java堆中的内存不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
  - 分配方式根据采用的垃圾回收算法实现。对于使用了压缩整理的垃圾收集器来说，java堆比较规整，因此使用指针碰撞的方式来分配。而对于CMS这种基于清除的算法收集器来讲，只能使用较为复杂的空闲列表分配内存。
  - 存在的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在**并发情况下也并不是线程安全**的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：一种是**对分配内存空间的动作进行同步处理**（实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性）；另外一种是**把内存分配的动作按照线程划分在不同的空间之中进行**，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲**（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。
- 初始化：
  - 分配完成后将内存空间初始化为0值（不包括对象头）
  - 对对象进行一些设置：对象是哪个类的实例、GC分代年龄信息等
- 执行构造函数

#### 4、对象内存布局

- 对象头
  - 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 类型指针，即对象指向它的类型元数据的指针，通过这个指针确定该对象是哪个类的实例
- 实例数据
  - 存储定义的各种类型的字段内容
- 对齐填充
  - 仅起着占位符的作用。例如HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，若对象实例数据部分没有对齐的话，就需要占位符对齐。

#### 5、对象的访问

- 句柄访问

  <img src="/Users/wangshangrong/Library/Application Support/typora-user-images/image-20201121154222452.png" alt="image-20201121154222452" style="zoom:50%;" />

  - 优点：reference中存储的是稳定的句柄地址，在对象被移动时（eg.垃圾回收整理），只会改变句柄中的实例数据指针，reference不需要改变。
  - 缺点：多一次指针定位的开销

- 指针访问

  <img src="/Users/wangshangrong/Library/Application Support/typora-user-images/image-20201121154315930.png" alt="image-20201121154315930" style="zoom:50%;" />

  - 优点：速度快，节省一次指针定位的时间开销（对象访问十分频繁）
  - 缺点：对象位置改变时reference也需要改变

  







