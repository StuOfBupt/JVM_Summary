#### 1、判定对象是否需要回收算法

- **引用计数法**

  - 通过在对象中添加一个引用计数器,每当有一个地方引用该对象时,计数器的值就加一,当引用失效时,计数值减一.任何时刻计数器值为零的对象就是无法被使用的,需要进行回收.
  - 优点：高效
  - 缺点：相互引用问题。例如，对象A和B分别有一个指向对方的引用，导致它们的引用计数都不为零，因此计数算法就无法回收这两个对象。
  - 主流的Java虚拟机并不采用这种方式

- **可达性分析**

  - 通过一系列被标记为根对象（GC Roots）作为起始节点，然后从这些节点出发，通过引用关系向下搜索，搜索过程中经过的路径称之为“引用链”。如果某个对象到根节点之间没有任何引用链（不可达），则证明该对象是不能被使用的。

    ![image-20201121161425917](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201121161425917.png?token=AHMLWBONCSPY5GM7P7V7CKC7XDGKW)

  - GC Roots一般有：

    - 虚拟机栈中引用的对象，例如各个线程中被调用的方法堆栈中使用的到的参数、局部变量、临时变量等
    - 方法区的静态属性引用对象、常量引用对象
    - Java虚拟机内部的引用，例如基本数据类型对应的Class对象、常驻的异常对象
    - 被同步锁持有的对象

#### 2、分代收集理论

- **强分代假说**：绝大多数对象都是朝生夕灭。

- **弱分代假说**：熬过越多次垃圾收集过程的对象就越难以清除。

- **跨带引用假说**：

  跨带引用相对于同代引用而言，仅仅只其中的少数。因为存在互相引用关系的两个对象，理论上是倾向于同时生存或者同时消亡的。例如，一个老年代对象引用一个新生代对象，老年代对象难以消亡，因此新生代对象也不会被清理掉，一段时间后新生代对象就会晋升为老年代对象，这样跨带引用就被消除了。因此就不应为了少量的跨代引用去遍历整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“**记忆集**“），把老年代区域划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后进行垃圾回收时，**只有包含了跨代引用的小块内存里的对象才会被加入到根节点进行分析。**

- **收集器的设计原则：**

  收集器应当将Java堆划分成不同的区域，然后将对象依照其年龄（经历垃圾回收的次数）分配到不同的区域中。因此，如果一个区域中的对象都是朝生夕灭的，那么就把它们集中在一起，每次进行垃圾回收时仅关注那些少量存活的对象，而无需去标记需要被清理的对象，这样就以较低的代价释放大量的空间。如果一个区域的对象都是较难清除的，就可以降低对这片区域进行垃圾回收的频率，同时兼顾了时间开销和内存空间的利用。现代的Java虚拟机中，一般会将Java堆至少分为新生代和老年代两个区域。

#### 3、垃圾收集算法

- **标记-清除**
  - 标记阶段：标记出所有需要回收的对象（或者标记存活的对象）
  - 回收阶段：统一回收掉所有被标记（或未被标记）的对象
  - 缺陷：
    - **执行效率不稳定**，如果堆区中包含大量的对象，其中大部分是需要回收的，就必须进行大量的标记和清除工作，随着对象数量增长，效率会降低许多。
    - **导致内存碎片化**，产生许多不连续的内存碎片，导致以后程序运行时需要分配较大空间时无法找到连续的内存空间而不得不提前触发下一次内存回收操作。
- **标记-复制**（半区复制）
  - 将可用内存按照容量划分为两等份，**每次只使用其中的一块**，当这部分内存使用完时，就将存活的对象复制到另外一份中，然后将剩下的内存一次清理掉。
  - 优点：不会产生大量的内存碎片
  - 缺陷：可用内存为原来的一半，若存活对象过多，需要进行大量的复制（一般用于新生代）。
  - 改进：不需要按照1：1的比例来划分新生代的内存空间（**统计指出：新生代中的对象有98%熬不过第一轮收集**）。一种做法是：将新生代内存划分为一块较大的空间（M）和两块较小（S）的空间，每次空间分配只用到M和一块S，当发生垃圾收集时，将M和这块S中仍然存活的对象复制到另一块S上，然后清理掉M和这块S，一般M和S的比例设置为8：1，这样代价就降低到了10%的内存空间。当然，存在一些情况下S的大小不足以容纳一次收集之后的对象时，**需要依赖其他的内存区域来进行分配担保**
- **标记-整理**
  - 标记阶段：与“标记-清除”算法相同
  - 整理阶段：让所有的存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
  - 缺陷：在老年代内存区域，每次回收都会有大量的对象存活区域，移动这些存活对象并更新引用将会是一种耗时的操作，并且需要全程暂停应用程序，如果不移动，就会导致大量的内存碎片。【从整体上看，移动对象会更加划算，因为内存访问和分配的次数要远远大于垃圾回收的次数】

#### 4、实现细节

- **根节点枚举**

  - 停顿所有用户线程，否则不能保证根节点集合的对象引用关系不变化
  - 在HotSpot 的解决方案里，是使用一组称为**OopMap（Ordinary Object Pointer， 普通对象指针）**的数据结构来达到这个目的。一旦类加载动作完成的时候， 就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会**在特定的位置记录下栈里和寄存器里哪些位置是引用**。这样收集器在扫描时就可以直接得知这些信息，并不需要真正一个不漏地从方法区等GC Roots开始查找。

- **安全点**

  - 如果为每条指令都生成**OOP**，那么空间成本就十分高昂，因此只需要在特定的位置上生成**OOP**信息，这些位置称之为安全点

  - 安全点的设置，也就限制了垃圾回收必须在到达安全点后才能执行。因此安全点的选取既不能太少也不能太多，太少则使得垃圾回收的间隔太长，太多则空间成本太大。

  - 安全点位置的选取基本上是以“**是否具有让程序长时间执行的特征”**为标准 进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等，所以只有具有这些功能的指令才会产生安全点。【耗时的指令处需要有安全点，否则收集器等待过长】 

  - 在发生垃圾收集时，如何让所有的线程都跑到最近的安全点，然后停顿下来？

    - **抢先式中断**：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。【现在几乎没有虚 

      拟机实现采用抢先式中断来暂停线程响应GC事件】

    - 主动式终端：不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去**轮询**这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。**轮询标志的地方和安全点是重合的**，另外**还要加上**所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。

      **轮询指令逻辑:轮询指令跟在OOP指令后面，每当经过OOP后立即执行轮询指令。这里，当需要进行垃圾回收时，虚拟机将0x160100的内存页设置为不可读，然后用户线程执行这个指令，访问内存页触发中断（内存保护陷阱，访问了一个不可读的内存页），然后通过在预先设置的异常处理器中挂起当前线程实现等待。**
      ![image-20201121201621826](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201121201621826.png?token=AHMLWBM4CZXXGXY2S7TBNVC7XECVS)

- **安全区域**：

  - 引入的原因：安全点只保证了**程序执行时**无需太久就可以遇到可进入垃圾回收过程的安全点，但是程序不执行的时候呢（例如没有被分配到CPU，处于sleep状态或者被阻塞状态）？虚拟机不会等待它重新执行再走到安全点。
  - 安全区域是指**能够确保在某一段代码片段之中，引用关系不会发生变化**，在这个区域中任意地方开始垃圾收集都是安全的。【被扩展拉伸了的安全点】
  - 当用户线程执行到安全区域里面的代码时，首先会**标识自己已经进入了安全区域**，这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止 

- **记忆集与卡表**：

  - 记忆集：用于记录从**非收集区域指向收集区域的指针集合**的抽象数据结构。

  - 没有必要将非收集区域的所有含跨代引用的对象记录到数组中（空间占用、维护成本高）

  - 通常收集器只需要判断某一块非收集区是否包含了指向了收集区域的指针，因此可以选择较大的记录粒度来节省记忆集的存储和维护成本：

    - 字长精度：每个记录精确到一个机器字长，该字包含跨代指针
    - 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
    - **卡精度**：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

  - 卡精度通过卡表实现。卡表是记忆集的一种实现，它定义了记忆集中的记录精度、与堆内存的映射关系等

  - 例如，用一个字节数组作为卡表

    > CARD_TABLE[this address >> 9] = 0

    字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块**特定大小的内存块**（“卡页”，Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，上面使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块

    ![image-20201121205359350](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201121205359350.png?token=AHMLWBKK2QSV7V2LNO3CIGC7XEHCM)

    一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变**脏（Dirty）**，没有则标识为0。在垃圾收集发生时，筛选出卡表中变脏的元素，就能得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。

- **写屏障**：解决卡表元素如何维护的问题

  - 卡表元素变脏的时机：变脏时间点原则上应该发生在引用类型字段赋值的那一刻。经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中。

  - 写屏障技术来维护卡表状态：写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作（无论更新的是不是老年代对新生代对象的引用）每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。

    - 在高并发状态下，更新卡表会有”**伪共享**“问题

      > 伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。 

    - 假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），**如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能**。为了避免伪共享问题，一种简单的解决方案是**不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏**：

      ```c
      if (CARD_TABLE[address >> 9] == 0)
        	CARD_TABLE[address >> 9] = 1;
      ```

      但这种方式会增加一次额外判断，两者各有性能损耗。

- **并发的可达性分析**

  从GC Roots开始往下遍历的时候，导致用户线程停顿的时间将会于堆容量直接成正比关系了，存储的对象越多，标记的对象也就越多，产生的停顿时间就更久。，因此需要并发的去完成可达性的分析。

  为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？三色标记问题：

  - 白色：表示对象尚未被垃圾收集器访问过。初始阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。 
  - 黑色：表示对象已经被垃圾收集器**完全扫描过**（这个对象的所有引用都已经扫描过），它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 
  - 灰色：表示对象已经被垃圾收集器访问过，但还未完全扫描（这个对象上至少存在一个引用还没有被扫描过）

  若收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果：一种是**把原本消亡的对象错误标记为存活**（可以容忍，只不过产生了一点逃过本次收集的浮动垃圾，下次收集清理掉就好）。另一种是**把原本存活的对象错误标记为已消亡**（致命，程序会因此发生错误），下面表演示了这样的致命错误具体是如何产生的：

  ![image-20201121213551784](https://raw.githubusercontent.com/StuOfBupt/MyTypora/master/img/image-20201121213551784.png?token=AHMLWBNKHS73VWZL7D7NVPC7XEL7S)

  > 理论证明，当且仅当以下两个条件**同时满足**时，会产生“对象消失”的问题： 
  >
  > 1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
  > 2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
  >
  > 因此，要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：
  >
  > - 增量更新：破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，**就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次**。简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象。
  > - 原始快照：破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，**就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次**。简化理解为，无论引用关系删除与否，都会**按照刚刚开始扫描那一刻的对象图快照来进行搜索**。 

  