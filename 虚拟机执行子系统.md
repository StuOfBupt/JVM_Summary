#### 1、类文件结构

- Java虚拟机不与任何语言绑定（包括Java），只与Class文件这种**特定的二进制文件格式**所关联，Class文件中包含了Java虚拟机指令集、符号表以及其他的辅助信息。Class文件是一组以8个字节为基础单位的二进制流，各个数据项目**严格按照顺序紧凑地排列在文** 

  **件之中，中间没有添加任何分隔符**，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。 

- Class文件格式式采用一种类似于C语言结构体的伪结构来存储数据，有两种数据类型：“无符号数”和“表”

  - 无符号数：以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述**数字、索引引用、数量值或者按照UTF-8编码构成字符串值**。
  - 表：由多个无符号数或者其他表作为数据项构成的复合数据类型，（所有表的命名都习惯性地以“**_info**”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。

- 魔数与Class文件版本

  - 每个Class文件的**头4个字节被称为魔数**（Magic Number），它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**，不使用文件扩展名是为了安全考虑，扩展名会被随意修改。魔数值为0xCAFEBABE
  - 紧接着魔数的4个字节存储的是Class文件的版本号，虚拟机拒绝执行超过其版本号的Class文件

- 常量池

  - 常量池入口在版本号之后
  - 常量的数量不固定，因此需要在入口处放置一个u2类型的数据，标识常量池的容量
  - **常量池的容量计数从1开始**：
    - 例如，容量为22表示常量池中有21项常量，索引范围为1~21。
    - 将第0项常量空出来的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“**不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示**
  - 常量池主要存放两大类常量：
    - 字面量：如文本字符串、被声明为final的常量值
    - 符号引用：如被模块导出或开放的包、类和接口的全限定名、方法的名称和描述符等
  - Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。
  - 常量池中每一项常量都是一个表，分别有17中不同类型的常量。这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位，代表着当前常量属于哪种常量类型。

- 访问标志

  - 占用两个字节，在常量池之后。
  - 用于识别一些类或者接口层次的访问信息。

- 类索引、父类索引与接口索引集合

  - 类索引：u2类型，用于确定这个类的全限定名
  - 父类索引：u2类型，用于确定类的父类，除了Object外，所有的Java类都有父类，索引不为0.
  - 接口索引：一组u2类型，描述类实现了哪些接口

- 字段表集合

  - 用于描述接口或者类中声明的变量。（包括类级变量（static）和实例级变量，但不包括在方法内声明的局部变量）
  - 字段表集合中不会列出从父类或者父接口中继承而来的字段

- 方法表集合

  - 与字段表集合的描述基本一致
  - 方法里的代码放在方法属性集合中名叫“Code”的属性中
  - 如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。

- 属性表集合

  - Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息
  - 不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息